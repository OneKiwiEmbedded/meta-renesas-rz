diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 2f01f50..9530924 100755
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -923,7 +923,7 @@ config ARCH_QEMU
 config ARCH_RMOBILE
 	bool "Renesas ARM SoCs"
 	select DM
-	select DM_SERIAL if !TARGET_RZV2M
+	select DM_SERIAL if !TARGET_RZV2M && !TARGET_RZV2MA
 	select GPIO_EXTRA_HEADER
 	imply BOARD_EARLY_INIT_F
 	imply CMD_DM
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 9d5fb26..fa8212e 100755
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -926,6 +926,7 @@ dtb-$(CONFIG_RCAR_GEN3) += \
 	smarc-rzg2l.dtb \
 	rzv2l-dev.dtb \
 	r9a09g011gbg-rzv2m-u-boot.dtb \
+	r9a09g055ma3gbg-rzv2ma-u-boot.dtb \
 	smarc-rzv2l.dtb \
 	rzg2lc-dev.dtb \
 	smarc-rzg2lc.dtb \
@@ -942,7 +943,8 @@ dtb-$(CONFIG_RZA1) += \
 	r7s72100-gr-peach-u-boot.dtb
 
 dtb-$(CONFIG_RCAR_64) += \
-	r9a09g011gbg-rzv2m-u-boot.dtb 
+	r9a09g011gbg-rzv2m-u-boot.dtb \
+	r9a09g055ma3gbg-rzv2ma-u-boot.dtb
 
 dtb-$(CONFIG_SOC_KEYSTONE) += keystone-k2hk-evm.dtb \
 	keystone-k2l-evm.dtb \
diff --git b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma-u-boot.dts b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma-u-boot.dts
new file mode 100755
index 0000000..776018f
--- /dev/null
+++ b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma-u-boot.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source extras for U-Boot for the RZV2MA board
+ *
+ * Copyright (C) 2022 Renesas Electronisc Corporation
+ */
+
+#include "r9a09g055ma3gbg-rzv2ma.dts"
+#include "r9a09g055ma3gbg-u-boot.dtsi"
+
diff --git b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma.dts b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma.dts
new file mode 100755
index 0000000..11f9eb3
--- /dev/null
+++ b/arch/arm/dts/r9a09g055ma3gbg-rzv2ma.dts
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Device Tree Source for the RZ/V2MA EVK platform
+ *
+ * Copyright (C) 2022 Renesas Electronics Corp.
+ */
+
+/dts-v1/;
+#include "r9a09g055ma3gbg.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "RZ/V2MA";
+	compatible = "evk,evk", "renesas,r9a09g055ma3gbg";
+
+	aliases {
+		ethernet0 = &avb;
+	};
+
+	chosen {
+		bootargs = "ignore_loglevel";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x0 0x80000000>;
+	};
+	memory@180000000 {
+                device_type = "memory";
+                reg = <0x1 0x80000000 0x0 0x80000000>;
+	};
+
+	reg_3p3v: regulator1 {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+	
+	vcc_sdhi0: regulator-vcc-sdhi0 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "SDHI0 Vcc";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vccq_sdhi0: regulator-vccq-sdhi0 {
+		compatible = "regulator-gpio";
+
+		regulator-name = "SDHI0 VccQ";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		states = <3300000 1 1800000 0>;
+	};
+
+};
+
+&avb {
+	status = "okay";
+};
+
+&pfc {
+	avb_pins: avb {
+		mux {
+			groups = "avb_link", "avb_mii";
+			function = "avb";
+		};
+	};
+};
+
+&extal_clk {
+	clock-frequency = <48000000>;
+};
+
+&sdhi0 {
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&vccq_sdhi0>;
+	status = "okay";
+};
+
+&eMM {
+	status = "okay";
+};
+
diff --git b/arch/arm/dts/r9a09g055ma3gbg-u-boot.dtsi b/arch/arm/dts/r9a09g055ma3gbg-u-boot.dtsi
new file mode 100755
index 0000000..ce2e1a0
--- /dev/null
+++ b/arch/arm/dts/r9a09g055ma3gbg-u-boot.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source extras for U-Boot on RZV2M r9a09g011gbg
+ *
+ * Copyright (C) 2018 Marek Vasut <marek.vasut@gmail.com>
+ */
+
+#include "r8a779x-u-boot.dtsi"
+
diff --git b/arch/arm/dts/r9a09g055ma3gbg.dtsi b/arch/arm/dts/r9a09g055ma3gbg.dtsi
new file mode 100755
index 0000000..0857406
--- /dev/null
+++ b/arch/arm/dts/r9a09g055ma3gbg.dtsi
@@ -0,0 +1,203 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Device Tree Source for the RZV2MA r9a09g055ma3gbg
+ *
+ * Copyright (C) 2022 Renesas Electronics Corp.
+ */
+
+#include <dt-bindings/clock/renesas-cpg-mssr.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/power/rzv2ma-sysc.h>
+
+/ {
+	compatible = "renesas,r9a09g055ma3gbg";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		a53_0: cpu@0 {
+			compatible = "arm,cortex-a53", "arm,armv8";
+			reg = <0x0>;
+			device_type = "cpu";
+			power-domains = <&sysc RZV2MA_PD_CA53>;
+			next-level-cache = <&L2_CA53>;
+		};
+
+		L2_CA53: cache-controller-0 {
+			compatible = "cache";
+			power-domains = <&sysc RZV2MA_PD_CA53_SCU>;
+			cache-unified;
+			cache-level = <2>;
+		};
+	};
+
+	extal_clk: extal {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		/* This value must be overridden by the board */
+		clock-frequency = <0>;
+	};
+	imclk: imclk@200M {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <200000000>;
+	};
+	ethclk: ethclk@200M {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <200000000>;
+	};
+
+	pmu_a53 {
+		compatible = "arm,cortex-a53-pmu";
+		interrupts-extended = <&gic GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&a53_0>;
+	};
+
+	soc: soc {
+		compatible = "simple-bus";
+		interrupt-parent = <&gic>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		sdhi0: sd@85000000 {
+			compatible = "renesas,sdhi-r9a09g011gbg",
+				     "renesas,rcar-gen3-sdhi";
+			reg = <0 0x85000000 0 0x2000>;
+			interrupts = <GIC_SPI 356 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 357 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&imclk>;
+			max-frequency = <200000000>;
+			bus-width = <4>;
+			cap-sd-highspeed;
+			non-removable;
+			no-1-8-v;
+			status = "disabled";
+		};
+		
+		eMM: sd@85020000 {
+			compatible = "renesas,sdhi-r9a09g011gbg",
+				     "renesas,rcar-gen3-sdhi";
+			reg = <0 0x85020000 0 0x2000>;
+			interrupts = <GIC_SPI 354 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 355 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&imclk>;
+			max-frequency = <200000000>;
+			bus-width = <8>;
+			non-removable;
+			status = "disabled";
+		};
+
+		/* PFC_base_addr = 0xB6250000 */
+		pfc: pin-controller@b6250000 {
+			compatible = "renesas,pfc-rzv2m";
+			reg = <0 0xb6250000 0 0x508>;
+		};
+
+                /* CPG_base_addr a3500000 */
+		cpg: clock-controller@a3500000 {
+			compatible = "renesas,rzv2m-cpg-mssr";
+			reg = <0 0xa3500000 0 0x1000>;
+			clocks = <&extal_clk>;
+			clock-names = "extal";
+			#clock-cells = <2>;
+			#power-domain-cells = <0>;
+			#reset-cells = <1>;
+		};
+
+		/* PMC_base_addr a3600000 */
+		sysc: system-controller@a3600000 {
+			compatible = "renesas,rzv2m-pmc";
+			reg = <0 0xa3600000 0 0x1000>;
+			#power-domain-cells = <1>;
+		};
+
+		/* EtherAVB e6800000 */
+		avb: ethernet@a3300000 {
+			compatible = "renesas,etheravb-rzv2m";
+			reg = <0 0xa3300000 0 0x800>;
+			interrupts = <GIC_SPI 251 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 252 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH 
+				     GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH 
+				     GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH 
+				     GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH 
+				     GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "ch0", "ch1", "ch2", "ch3",
+					  "ch4", "ch5", "ch6", "ch7",
+					  "ch8", "ch9", "ch10", "ch11",
+					  "ch12", "ch13", "ch14", "ch15",
+					  "ch16", "ch17", "ch18", "ch19",
+					  "ch20", "ch21", "ch22", "ch23",
+					  "ch24";
+			clocks = <&ethclk>;
+			renesas,no-ether-link;
+			phy-handle = <&phy0>;
+			phy-mode = "gmii";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+			
+			phy0: ethernet-phy@0 {
+				rxc-skew-ps = <1500>;
+				reg = <0>;
+				#interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+			};
+		};
+
+		/* GIC_GICD_base_addr 82010000 */
+		gic: interrupt-controller@82010000 {
+			compatible = "arm,gic-400";
+			#interrupt-cells = <3>;
+			#address-cells = <0>;
+			interrupt-controller;
+			reg = <0x0 0x82010000 0 0x1000>,
+			      <0x0 0x82020000 0 0x20000>,
+			      <0x0 0x82040000 0 0x20000>,
+			      <0x0 0x82060000 0 0x20000>;
+			interrupts = <GIC_PPI 9
+					(GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_HIGH)>;
+			clocks = <&cpg CPG_MOD 408>;
+			clock-names = "clk";
+			power-domains = <&sysc RZV2MA_PD_ALWAYS_ON>;
+			resets = <&cpg 408>;
+		};
+		
+		prr: chipid@fff00044 {
+			compatible = "renesas,prr";
+			reg = <0 0xfff00044 0 4>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts-extended = <&gic GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+};
diff --git a/arch/arm/mach-rmobile/Kconfig.64 b/arch/arm/mach-rmobile/Kconfig.64
index 2b36fb3..3642a21 100755
--- a/arch/arm/mach-rmobile/Kconfig.64
+++ b/arch/arm/mach-rmobile/Kconfig.64
@@ -266,6 +266,9 @@ choice
 config R9A09G011GBG
        bool "Renesas RZV2M r9a09g011gbg"
 
+config R9A09G055MA3GBG
+       bool "Renesas RZV2MA r9a09g055ma3gbg"
+
 endchoice
 
 
@@ -274,10 +277,14 @@ choice
        optional
 
 config TARGET_RZV2M
-       bool "RZV2M board"
+       bool "RZV2M EVK board"
        help
           Support for Renesas RZV2M platform
 
+config TARGET_RZV2MA
+       bool "RZV2MA EVK board"
+       help
+          Support for Renesas RZV2MA platform
 
 endchoice
 
@@ -285,6 +292,7 @@ config SYS_SOC
        default "rmobile"
 
 source "board/renesas/rzv2m-dev/Kconfig"
+source "board/renesas/rzv2ma-dev/Kconfig"
 
 endif
 
diff --git a/arch/arm/mach-rmobile/Makefile b/arch/arm/mach-rmobile/Makefile
index 90d9c57..493d310 100755
--- a/arch/arm/mach-rmobile/Makefile
+++ b/arch/arm/mach-rmobile/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_R8A7740) += lowlevel_init.o cpu_info-r8a7740.o pfc-r8a7740.o
 obj-$(CONFIG_RCAR_GEN2) += lowlevel_init_ca15.o cpu_info-rcar.o
 obj-$(CONFIG_RCAR_GEN3) += lowlevel_init_gen3.o cpu_info-rcar.o memmap-gen3.o
 obj-$(CONFIG_R9A09G011GBG) += lowlevel_init_gen3.o memmap-r9a09G011.o
+obj-$(CONFIG_R9A09G055MA3GBG) += lowlevel_init_gen3.o memmap-r9a09g055ma3gbg.o
 obj-$(CONFIG_RZ_G2) += cpu_info-rzg.o
 
 ifneq ($(CONFIG_R8A779A0),)
diff --git b/arch/arm/mach-rmobile/include/mach/r9a09g055ma3gbg.h b/arch/arm/mach-rmobile/include/mach/r9a09g055ma3gbg.h
new file mode 100755
index 0000000..78f6242
--- /dev/null
+++ b/arch/arm/mach-rmobile/include/mach/r9a09g055ma3gbg.h
@@ -0,0 +1,35 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/#ifndef __ASM_ARCH_R9A09G055MA3GBG_H
+#define __ASM_ARCH_R9A09G055MA3GBG_H
+
+/*
+   + * R9A09G055MA3GBG I/O Addresses
+   + */
+
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+#endif
+
+#endif /* __ASM_ARCH_R9A09G055MA3GBG_H */
diff --git a/arch/arm/mach-rmobile/include/mach/rmobile.h b/arch/arm/mach-rmobile/include/mach/rmobile.h
index 900426f..ebe50ea 100755
--- a/arch/arm/mach-rmobile/include/mach/rmobile.h
+++ b/arch/arm/mach-rmobile/include/mach/rmobile.h
@@ -20,6 +20,8 @@
 #include <asm/arch/rcar-gen3-base.h>
 #elif defined(CONFIG_R9A09G011GBG)
 #include <asm/arch/r9a09g011.h>
+#elif defined(CONFIG_R9A09G055MA3GBG)
+#include <asm/arch/r9a09g055ma3gbg.h>
 #elif defined(CONFIG_R7S72100)
 #else
 #error "SOC Name not defined"
diff --git b/arch/arm/mach-rmobile/memmap-r9a09g055ma3gbg.c b/arch/arm/mach-rmobile/memmap-r9a09g055ma3gbg.c
new file mode 100755
index 0000000..2850629
--- /dev/null
+++ b/arch/arm/mach-rmobile/memmap-r9a09g055ma3gbg.c
@@ -0,0 +1,73 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/
+#include <common.h>
+#include <asm/armv8/mmu.h>
+
+#define R9A09G055MA3GBG_NR_REGIONS 16
+
+static struct mm_region r9a09g055ma3gbg_mem_map[R9A09G055MA3GBG_NR_REGIONS] = {
+	{
+		/* DDR 1-S */
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* Slave */
+		.virt = 0x80000000UL,
+		.phys = 0x80000000UL,
+		.size = 0x40000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* PCI */
+		.virt = 0xc0000000UL,
+		.phys = 0xc0000000UL,
+		.size = 0x40000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* DDR 1-M */
+		.virt = 0x100000000UL,
+		.phys = 0x100000000UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* DDR 2 */
+		.virt = 0x180000000UL,
+		.phys = 0x180000000UL,
+		.size = 0x180000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = r9a09g055ma3gbg_mem_map;
+
diff --git b/board/renesas/rzv2ma-dev/Kconfig b/board/renesas/rzv2ma-dev/Kconfig
new file mode 100755
index 0000000..b973161
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_RZV2MA
+
+config SYS_SOC
+	default "rmobile"
+
+config SYS_BOARD
+	default "rzv2ma-dev"
+
+config SYS_VENDOR
+	default "renesas"
+
+config SYS_CONFIG_NAME
+	default "rzv2ma"
+
+endif
diff --git b/board/renesas/rzv2ma-dev/Makefile b/board/renesas/rzv2ma-dev/Makefile
new file mode 100755
index 0000000..676c297
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/Makefile
@@ -0,0 +1,9 @@
+#
+# board/renesas/rzv2ma-dev/Makefile
+#
+# Copyright (C) 2022 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+obj-y	:= rzv2ma-dev.o evk_cmn_cpg.o evk_common.o evk_sys.o evk_psc.o
diff --git b/board/renesas/rzv2ma-dev/evk_cmn_cpg.c b/board/renesas/rzv2ma-dev/evk_cmn_cpg.c
new file mode 100755
index 0000000..66bb1f1
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_cmn_cpg.c
@@ -0,0 +1,472 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_cmn_cpg.c
+ * Description  : operation functions for CPG
+ ******************************************************************************/
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "evk_common.h"
+#include "evk_cmn_cpg.h"
+
+#define CPG_NO_REGISTER_OFFSET          (0xFFFFFFFF)
+#define CPG_TIMEOUT_UNIT_IS_US          (10)
+
+typedef struct
+{
+    unsigned int pll_used_cnt[CPG_PLL_MAX+1];
+} st_cpg_priv_t;
+
+static st_cpg_priv_t gl_cpg_priv =
+{
+    .pll_used_cnt = { 0 },
+};
+
+static st_cpg_pll_param_t pll1_param =
+{
+    .ssc.word    = 0x00000004,
+    .clk.word[0] = 0x000014C2,
+    .clk.word[1] = 0x00150801
+};
+
+static st_cpg_pll_param_t pll2_param =
+{
+    .ssc.word    = 0x00000004,
+    .clk.word[0] = 0x00001903,
+    .clk.word[1] = 0x000E0E00
+};
+
+/** 600MHz w/o SSCG */
+static st_cpg_pll_param_t pll3_param =
+{
+    .ssc.word    = 0x00000000,
+    .clk.word[0] = 0x00001903,
+    .clk.word[1] = 0x00100800
+};
+
+static st_cpg_pll_param_t pll4_param =
+{
+    .ssc.word    = 0x00000000,
+    .clk.word[0] = 0x00001802,
+    .clk.word[1] = 0x00000002
+};
+
+static st_cpg_pll_param_t pll6_param =
+{
+    .ssc.word    = 0x00000000,
+    .clk.word[0] = 0x00001A42,
+    .clk.word[1] = 0x00150A01
+};
+
+static st_cpg_pll_param_t pll7_param =
+{
+    .ssc.word    = 0x00000004,
+    .clk.word[0] = 0x000018C2,
+    .clk.word[1] = 0x00150A01
+};
+
+static st_cpg_pll_param_t * const gl_priv_pll_param_tbl[CPG_PLL_MAX+1] =
+{
+    NULL,
+    &pll1_param,
+    &pll2_param,
+    &pll3_param,
+    &pll4_param,
+    NULL,
+    &pll6_param,
+    &pll7_param
+};
+
+static const unsigned int gl_priv_pll_top_offset_table[CPG_PLL_MAX+1] =
+{
+    CPG_NO_REGISTER_OFFSET,
+    CPG_PLL1_STBY,
+    CPG_PLL2_STBY,
+    CPG_PLL3_STBY,
+    CPG_PLL4_STBY,
+    CPG_NO_REGISTER_OFFSET,
+    CPG_PLL6_STBY,
+    CPG_PLL7_STBY,
+};
+
+#define CPG_REG_WEN_SHIFT           (16)
+#define CPG_SET_DATA_MASK           (0x0000FFFFUL)
+
+#define CPG_PLLN_STBY_OFFSET        (0x00)
+#define CPG_PLLN_CLK1_OFFSET        (0x04)
+#define CPG_PLLN_CLK2_OFFSET        (0x08)
+#define CPG_PLLN_MON_OFFSET         (0x0C)
+
+#define CPG_PLL_CCTRL_REG_EXIT_FLAGS    (0x0000009E)
+
+#define CPG_TIMEOUT_UNIT_IN_US      (10)
+#define CPG_PLL_TURN_MODE_TIMEOUT   (500000)
+#define CPG_CLK_FINISH_CHANGE_TIMEOUT   (500000)
+#define CPG_PLL_LOCKED  (CPG_PLL_MON_PLL_LOCK)
+
+
+#define CPG_WAIT_EVENT_PLL(m_pll, m_toc, m_err_code, m_condition, m_rslt)   \
+    {   \
+        unsigned int count = (m_toc);   \
+        unsigned int data;  \
+        while (true) {  \
+            CPG_GetStatusPLL((m_pll), &data);   \
+            if ((m_condition) == (data & CPG_PLL_LOCKED)) { \
+                (m_rslt) = CMN_SUCCESS; \
+                break;  \
+            }   \
+            if ((0 == (m_toc)) || (0 < count)) {    \
+                CMN_DelayInUS(CPG_TIMEOUT_UNIT_IN_US);  \
+                count--;    \
+            } else {    \
+                (m_rslt) = (m_err_code);    \
+                break;  \
+            }   \
+        }   \
+    }
+
+#define CPG_WAIT_EVENT(m_toc, m_err_code, m_condition, m_rslt)  \
+    {   \
+        unsigned int count = (m_toc)/CPG_TIMEOUT_UNIT_IN_US;    \
+        while (true) {  \
+            if ((m_condition)) {    \
+                (m_rslt) = CMN_SUCCESS; \
+                break;  \
+            }   \
+            if ((0 == (m_toc)) || (0 < count)) {    \
+                CMN_DelayInUS(CPG_TIMEOUT_UNIT_IN_US);  \
+                count--;    \
+            } else {    \
+                (m_rslt) = (m_err_code);    \
+                break;  \
+            }   \
+        }   \
+    }
+
+
+unsigned int CPG_ReadReg(unsigned int offset)
+{
+    return (CMN_REG_Read32(CPG_BASE_ADDRESS + offset));
+}
+
+void CPG_WriteReg(unsigned int offset, unsigned int value)
+{
+    CMN_REG_Write32((CPG_BASE_ADDRESS + offset), value);
+}
+
+
+int CPG_MoveToActivePLL(e_cpg_pll_num_t pll_num, st_cpg_pll_param_t *p_set_data)
+{
+    unsigned int offset;
+    unsigned int value;
+
+    if ((pll_num < CPG_PLL_MIN) || (CPG_PLL_MAX < pll_num))
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    offset = gl_priv_pll_top_offset_table[pll_num];
+    if (CPG_NO_REGISTER_OFFSET == offset)
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    value = CPG_ReadReg(offset+CPG_PLLN_MON_OFFSET);
+    if (0 != (value & CPG_PLL_MON_RESETB))
+    {
+        return (CPG_ERROR_PLL_ACTIVE);
+    }
+
+    if (NULL != p_set_data)
+    {
+        value = p_set_data->clk.word[0];
+        CPG_WriteReg(offset+CPG_PLLN_CLK1_OFFSET, value);
+        value = p_set_data->clk.word[1];
+        CPG_WriteReg(offset+CPG_PLLN_CLK2_OFFSET, value);
+        value = p_set_data->ssc.word;
+    }else
+    {
+        value = CPG_ReadReg(offset+CPG_PLLN_STBY_OFFSET);
+    }
+
+    if (4 == pll_num)
+    {
+        value = 0x00010001;
+    }else
+    {
+        value |= 0x00150001;
+        value = 0x00050001;    /* Setting up 1chip sim environment */
+    }
+
+    CPG_WriteReg(offset+CPG_PLLN_STBY_OFFSET, value);
+
+    return (CMN_SUCCESS);
+}
+
+int CPG_GetStatusPLL(e_cpg_pll_num_t pll_num, unsigned int *p_data)
+{
+    unsigned int offset;
+    if ((pll_num < CPG_PLL_MIN) || (CPG_PLL_MAX < pll_num))
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    offset = gl_priv_pll_top_offset_table[pll_num];
+    if (CPG_NO_REGISTER_OFFSET == offset)
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    if (NULL == p_data)
+    {
+        return (CPG_ERROR_NULL_POINTER);
+    }
+
+    offset += CPG_PLLN_MON_OFFSET;
+
+    *p_data = CPG_ReadReg(offset);
+
+    return (CMN_SUCCESS);
+}
+
+
+void CPG_SetDifClkFreq(e_cpg_divsel_t target_reg, unsigned short int target, unsigned short int set_value)
+{
+    unsigned int offset = CPG_CA53_DDIV;
+    unsigned int value;
+
+    while (true)
+    {
+        if (0 == (CPG_ReadReg(CPG_CLKSTATUS) & CPG_CLKSTATUS_DIVX))
+        {
+            break;
+        }
+        CMN_DelayInUS(CPG_TIMEOUT_UNIT_IN_US);
+    }
+
+    offset += (target_reg * sizeof(unsigned int));
+
+    value = ((unsigned int)target << CPG_REG_WEN_SHIFT)
+                | (set_value & CPG_MMCDDI_DDIV_DIVX_SET_MSK);
+
+    CPG_WriteReg(offset, value);
+
+    while (true)
+    {
+        if (0 == (CPG_ReadReg(CPG_CLKSTATUS) & CPG_CLKSTATUS_DIVX))
+        {
+            break;
+        }
+        CMN_DelayInUS(CPG_TIMEOUT_UNIT_IN_US);
+    }
+}
+
+
+int CPG_SetClockCtrl(unsigned char reg_num, unsigned short int target, unsigned short int set_value)
+{
+    unsigned int offset = CPG_CLK_ON1;
+    unsigned int value;
+
+    if (reg_num < CPG_CLK_ON_REG_MIN || CPG_CLK_ON_REG_MAX < reg_num)
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    offset += ((reg_num - 1) * sizeof(unsigned int));
+
+    value = ((unsigned int)target << CPG_REG_WEN_SHIFT)
+            | (set_value & CPG_SET_DATA_MASK);
+
+    CPG_WriteReg(offset, value);
+
+    return (CMN_SUCCESS);
+}
+
+
+int CPG_GetClockCtrl(unsigned char reg_num, unsigned int *p_data)
+{
+    unsigned int offset = CPG_CLK_ON1;
+
+    if (reg_num < CPG_CLK_ON_REG_MIN || CPG_CLK_ON_REG_MAX < reg_num)
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+    if (NULL == p_data)
+    {
+        return (CPG_ERROR_NULL_POINTER);
+    }
+
+    offset += ((reg_num - 1) * sizeof(unsigned int));
+
+    *p_data = CPG_ReadReg(offset);
+
+    return (CMN_SUCCESS);
+}
+
+
+int CPG_SetResetCtrl(unsigned char reg_num, unsigned short int target, unsigned short int set_value)
+{
+    unsigned int offset = CPG_RST1;
+    unsigned int value;
+
+    if (reg_num < CPG_RST_REG_MIN || CPG_RST_REG_MAX < reg_num)
+    {
+        return (CPG_ERROR_NO_REGISTER);
+    }
+
+    offset += ((reg_num - 1) * sizeof(unsigned int));
+
+    value = ((unsigned int)target << CPG_REG_WEN_SHIFT) | (set_value & CPG_SET_DATA_MASK);
+
+    CPG_WriteReg(offset, value);
+
+    return (CMN_SUCCESS);
+}
+
+
+int CPG_SetPDResetCtrl(unsigned short int target, unsigned short int set_value)
+{
+    unsigned int offset = CPG_PD_RST;
+    unsigned int value;
+
+    value = ((unsigned int)target << CPG_REG_WEN_SHIFT) | (set_value & CPG_SET_DATA_MASK);
+
+    CPG_WriteReg(offset, value);
+
+    return (CMN_SUCCESS);
+}
+
+
+int CPG_WaitResetMon(unsigned int timeout_c, unsigned int msk, unsigned int val)
+{
+    int rslt = CMN_ERROR;
+    unsigned int count;
+
+    do
+    {
+        if (0 == msk)
+        {
+            rslt = CMN_SUCCESS;
+            break;
+        }
+
+        count = timeout_c;
+        while (true)
+        {
+            if (val == (CPG_ReadReg(CPG_RST_MON) & msk))
+            {
+                rslt = CMN_SUCCESS;
+                break;
+            }
+            if ((0 == timeout_c) || (0 < count))
+            {
+                CMN_DelayInUS(CPG_TIMEOUT_UNIT_IS_US);
+                count--;
+            }else
+            {
+                rslt = CPG_ERROR_TURN_RESET_TIMEOUT;
+                break;
+            }
+        }
+    }
+    while (0);
+
+    return rslt;
+}
+
+
+int cpg_resumePLL(e_cpg_pll_num_t pll_num)
+{
+    int rslt;
+    unsigned int data;
+    st_cpg_pll_param_t *p_data = NULL;
+
+    do
+    {
+        rslt = CPG_GetStatusPLL(pll_num, &data);
+        if (CMN_SUCCESS != rslt)
+        {
+            break;
+        }
+        if (0 != (data & CPG_PLL_LOCKED))
+        {
+            rslt = CPG_ERROR_PLL_NOT_STANDBY | pll_num;
+            break;
+        }
+
+        p_data = gl_priv_pll_param_tbl[pll_num];
+        rslt = CPG_MoveToActivePLL(pll_num, p_data);
+
+        if (CMN_SUCCESS != rslt)
+        {
+            break;
+        }
+
+        CPG_WAIT_EVENT_PLL(pll_num, CPG_PLL_TURN_MODE_TIMEOUT, CPG_ERROR_PLL_TURN_MODE_TIMEOUT, CPG_PLL_LOCKED, rslt);
+
+        if (CMN_SUCCESS != rslt)
+        {
+            break;
+        }
+            }
+
+    while (0);
+
+    return rslt;
+}
+
+int CPG_WakeUpPLL(e_cpg_pll_num_t pll_num)
+{
+    int rslt = CMN_ERROR;
+
+    do
+    {
+        if ((pll_num < CPG_PLL_MIN) || (CPG_PLL_MAX < pll_num))
+        {
+            rslt = CPG_ERROR_NO_REGISTER;
+            break;
+        }
+
+        if (0 == gl_cpg_priv.pll_used_cnt[pll_num])
+        {
+            rslt = cpg_resumePLL(pll_num);
+            if (CMN_SUCCESS != rslt)
+            {
+                break;
+            }
+            gl_cpg_priv.pll_used_cnt[pll_num]++;
+        }else
+        {
+            gl_cpg_priv.pll_used_cnt[pll_num]++;
+            rslt = CMN_SUCCESS;
+        }
+    }
+    while (0);
+
+    return rslt;
+}
+
+
+/*- End of file -*/
diff --git b/board/renesas/rzv2ma-dev/evk_cmn_cpg.h b/board/renesas/rzv2ma-dev/evk_cmn_cpg.h
new file mode 100755
index 0000000..7972050
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_cmn_cpg.h
@@ -0,0 +1,312 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_cmn_cpg.h
+ * Description  : register and API information for CPG
+ ******************************************************************************/
+
+#ifndef EVK_CMN_CPG_H
+#define EVK_CMN_CPG_H
+
+/* CPG */
+#define CPG_BASE_ADDRESS        (0x0A3500000ULL)
+
+/** Registor Offset */
+#define CPG_PLL1_STBY           (0x0000)
+#define CPG_PLL1_CLK1           (0x0004)
+#define CPG_PLL1_CLK2           (0x0008)
+#define CPG_PLL1_MON            (0x000C)
+#define CPG_PLL2_STBY           (0x0010)
+#define CPG_PLL2_CLK1           (0x0014)
+#define CPG_PLL2_CLK2           (0x0018)
+#define CPG_PLL2_MON            (0x001C)
+#define CPG_PLL3_STBY           (0x0020)
+#define CPG_PLL3_CLK1           (0x0024)
+#define CPG_PLL3_CLK2           (0x0028)
+#define CPG_PLL3_MON            (0x002C)
+#define CPG_PLL6_STBY           (0x0030)
+#define CPG_PLL6_CLK1           (0x0034)
+#define CPG_PLL6_CLK2           (0x0038)
+#define CPG_PLL6_MON            (0x003C)
+#define CPG_PLL7_STBY           (0x0040)
+#define CPG_PLL7_CLK1           (0x0044)
+#define CPG_PLL7_CLK2           (0x0048)
+#define CPG_PLL7_MON            (0x004C)
+
+
+#define CPG_PLL4_STBY           (0x0100)
+#define CPG_PLL4_CLK1           (0x0104)
+#define CPG_PLL4_CLK2           (0x0108)
+#define CPG_PLL4_MON            (0x010C)
+
+
+#define CPG_PLL1_CCTRL_RST      (0x0180)
+#define CPG_PLL2_CCTRL_RST      (0x0184)
+#define CPG_PLL3_CCTRL_RST      (0x0188)
+#define CPG_PLL4_CCTRL_RST      (0x018C)
+
+#define CPG_PLL7_CCTRL_RST      (0x0198)
+
+#define CPG_CA53_DDIV           (0x0200)
+#define CPG_SYS_DDIV            (0x0204)
+#define CPG_MMCDDI_DDIV         (0x0210)
+#define CPG_CLK48_DSEL          (0x0214)
+#define CPG_CLKSTATUS           (0x0224)
+
+
+#define CPG_SDIEMM_SSEL         (0x0300)
+#define CPG_GMCLK_SDIV          (0x031C)
+#define CPG_GMCLK_SSEL          (0x0320)
+#define CPG_URT_RCLK_SDIV       (0x0328)
+#define CPG_URT_RCLK_SSEL       (0x032C)
+#define CPG_CSI_RCLK_SSEL       (0x0330)
+
+
+#define CPG_CLK_ON1             (0x0400)
+#define CPG_CLK_ON2             (0x0404)
+#define CPG_CLK_ON3             (0x0408)
+#define CPG_CLK_ON4             (0x040C)
+#define CPG_CLK_ON5             (0x0410)
+#define CPG_CLK_ON6             (0x0414)
+#define CPG_CLK_ON7             (0x0418)
+#define CPG_CLK_ON8             (0x041C)
+#define CPG_CLK_ON9             (0x0420)
+#define CPG_CLK_ON10            (0x0424)
+#define CPG_CLK_ON11            (0x0428)
+#define CPG_CLK_ON12            (0x042C)
+#define CPG_CLK_ON13            (0x0430)
+#define CPG_CLK_ON14            (0x0434)
+#define CPG_CLK_ON15            (0x0438)
+#define CPG_CLK_ON16            (0x043C)
+#define CPG_CLK_ON17            (0x0440)
+#define CPG_CLK_ON18            (0x0444)
+#define CPG_CLK_ON19            (0x0448)
+#define CPG_CLK_ON20            (0x044C)
+#define CPG_CLK_ON21            (0x0450)
+#define CPG_CLK_ON22            (0x0454)
+#define CPG_CLK_ON23            (0x0458)
+#define CPG_CLK_ON24            (0x045C)
+#define CPG_CLK_ON25            (0x0460)
+#define CPG_CLK_ON26            (0x0464)
+#define CPG_CLK_ON27            (0x0468)
+
+#define CPG_RST_MSK             (0x0504)
+
+
+#define CPG_RST1                (0x0600)
+#define CPG_RST2                (0x0604)
+#define CPG_RST3                (0x0608)
+#define CPG_RST4                (0x060C)
+#define CPG_RST5                (0x0610)
+#define CPG_RST6                (0x0614)
+#define CPG_RST7                (0x0618)
+#define CPG_RST8                (0x061C)
+#define CPG_RST9                (0x0620)
+#define CPG_RST10               (0x0624)
+#define CPG_RST11               (0x0628)
+#define CPG_RST12               (0x062C)
+#define CPG_RST13               (0x0630)
+#define CPG_RST14               (0x0634)
+#define CPG_RST15               (0x0638)
+
+
+#define CPG_RST_MON             (0x0680)
+
+#define CPG_PD_RST              (0x0800)
+
+
+/** Bit assign */
+#define CPG_PLL_STBY_RESETB                 (0x00000001)
+#define CPG_PLL_STBY_WEN_RESETB             (0x00010000)
+#define CPG_PLL_STBY_WEN_SSE_EN             (0x00040000)
+#define CPG_PLL_STBY_WEN_SSC_MODE           (0x00100000)
+
+#define CPG_PLL_MON_RESETB                  (0x00000001)
+#define CPG_PLL_MON_PLL_LOCK                (0x00000010)
+
+#define CPG_PLL1_CCTRL_RST_P1_0_RST         (0x00000001)
+#define CPG_PLL1_CCTRL_WEN_RST_P1_0_RST     (0x00010000)
+
+#define CPG_CA53_DDIV_DIVA_SET_MIN          (0)
+#define CPG_CA53_DDIV_WEN_DIVA              (0x00010000)
+
+#define CPG_SYS_DDIV_DIVD_SET_SHIFT         (4)
+#define CPG_SYS_DDIV_DIVD_SET_MIN           (0)
+#define CPG_SYS_DDIV_DIVE_SET_SHIFT         (8)
+#define CPG_SYS_DDIV_DIVE_SET_MIN           (0)
+#define CPG_SYS_DDIV_WEN_DIVB               (0x00010000)
+#define CPG_SYS_DDIV_WEN_DIVD               (0x00100000)
+#define CPG_SYS_DDIV_WEN_DIVE               (0x01000000)
+
+#define CPG_MMCDDI_DDIV_DIVX_SET_MSK        (0x00000003)
+#define CPG_MMCDDI_DDIV_DIVX_SET_SHIFT      (0)
+#define CPG_MMCDDI_DDIV_DIVX_SET_MAX        (2)
+#define CPG_MMCDDI_DDIV_DIVX_SET_MIN        (0)
+#define CPG_MMCDDI_DDIV_WEN_DIVX            (0x00010000)
+
+#define CPG_CLK48_DSEL_SELD                 (0x00000002)
+#define CPG_CLK48_DSEL_SELE                 (0x00000004)
+#define CPG_CLK48_DSEL_WEN_SELD             (0x00020000)
+#define CPG_CLK48_DSEL_WEN_SELE             (0x00040000)
+
+#define CPG_SDIEMM_SSEL_SELSDI              (0x00000001)
+#define CPG_SDIEMM_SSEL_WEN_SELSDI          (0x00010000)
+
+#define CPG_URT_RCLK_SSEL_WEN_SELW0         (0x00010000)
+
+#define CPG_CLKSTATUS_DIVA                  (0x00000001)
+#define CPG_CLKSTATUS_DIVB                  (0x00000002)
+#define CPG_CLKSTATUS_DIVD                  (0x00000004)
+#define CPG_CLKSTATUS_DIVE                  (0x00000008)
+#define CPG_CLKSTATUS_DIVF                  (0x00000010)
+#define CPG_CLKSTATUS_DIVG                  (0x00000020)
+#define CPG_CLKSTATUS_DIVNFI                (0x00000040)
+#define CPG_CLKSTATUS_DIVX                  (0x00000080)
+#define CPG_CLKSTATUS_DIVH                  (0x00000100)
+#define CPG_CLKSTATUS_DIVI                  (0x00000200)
+#define CPG_CLKSTATUS_DIVJ                  (0x00000400)
+#define CPG_CLKSTATUS_DIVM                  (0x00000800)
+#define CPG_CLKSTATUS_DIVH2                 (0x00001000)
+
+#define CPG_PD_RST_MEM_RSTB                 (0x00000001)
+#define CPG_PD_RST_WEN_MEM_RSTB             (0x00010000)
+
+#define CPG_RST_MON_DMAA                    (0x00000010)
+#define CPG_RST_MON_SDI0                    (0x00000040)
+#define CPG_RST_MON_SDI1                    (0x00000080)
+#define CPG_RST_MON_EMM                     (0x00000100)
+#define CPG_RST_MON_ETH0                    (0x00000800)
+#define CPG_RST_MON_PWM_0                   (0x00400000)
+#define CPG_RST_MON_PWM_1                   (0x00800000)
+#define CPG_RST_MON_CSI_1                   (0x01000000)
+#define CPG_RST_MON_CSI_2                   (0x02000000)
+#define CPG_RST_MON_URT                     (0x04000000)
+#define CPG_PD_RST_RFX_RSTB                 (0x00000010)
+#define CPG_PD_RST_WEN_RFX_RSTB             (0x00100000)
+
+#define CPG_PLL_MIN                         (1)
+#define CPG_PLL_MAX                         (7)
+
+#define CPG_CLK_ON_REG_MIN                  (1)
+#define CPG_CLK_ON_REG_MAX                  (27)
+
+#define CPG_RST_REG_MIN                     (1)
+#define CPG_RST_REG_MAX                     (15)
+
+typedef struct
+{
+    union
+    {
+        unsigned int        word;
+        struct
+        {
+            unsigned int    :2;
+            unsigned int    enable:1;
+            unsigned int    :1;
+            unsigned int    mode:2;
+            unsigned int    :26;
+        }bit;
+    }ssc;
+    union
+    {
+        unsigned int        word[2];
+        struct
+        {
+            unsigned int    p:6;
+            unsigned int    m:10;
+            unsigned int    k:16;
+            unsigned int    s:3;
+            unsigned int    :5;
+            unsigned int    mrr:6;
+            unsigned int    :2;
+            unsigned int    mfr:8;
+            unsigned int    :8;
+        } bit;
+    } clk;
+} st_cpg_pll_param_t;
+
+typedef enum
+{
+    CPG_ERROR_ARGUMENT               = -201,
+    CPG_ERROR_NO_REGISTER            = -202,
+    CPG_ERROR_NULL_POINTER           = -203,
+    CPG_ERROR_PLL_TURN_MODE_TIMEOUT  = -204,
+    CPG_ERROR_PLL_ACTIVE             = -205,
+    CPG_ERROR_PLL_STANDBY            = -206,
+    CPG_ERROR_TURN_RESET_TIMEOUT     = -207,
+    CPG_ERROR_CLK_CHANGE_TIMEOUT     = -208,
+    CPG_ERROR_PLL_NOT_ACTIVE         = -280,
+    CPG_ERROR_PLL_NOT_STANDBY        = -290
+} e_cpg_error_code_t;
+
+typedef enum
+{
+    CPG_PLL_1 = 1,
+    CPG_PLL_2 = 2,
+    CPG_PLL_3 = 3,
+    CPG_PLL_4 = 4,
+    CPG_PLL_6 = 6,
+    CPG_PLL_7 = 7
+} e_cpg_pll_num_t;
+
+typedef enum
+{
+    CPG_DDIV_CA53 = 0,
+    CPG_DDIV_SYS,
+    CPG_dmy1,
+    CPG_dmy2,
+    CPG_DDIV_MMCDDI,
+    CPG_DSEL_CLK48,
+    CPG_dmy3,
+    CPG_dmy4,
+    CPG_dmy5,
+    CPG_SSEL_SDIEMM = 64,
+    CPG_dmy6,
+    CPG_dmy7,
+    CPG_dmy8,
+    CPG_dmy9,
+    CPG_dmyA,
+    CPG_dmyB,
+    CPG_SDIV_GMCLK,
+    CPG_SSEL_GMCLK,
+    CPG_dmyC,
+    CPG_SDIV_URT_RCLK,
+    CPG_SSEL_URT_RCLK,
+    CPG_SSEL_CSI_RCLK
+} e_cpg_divsel_t;
+
+/** prototype defined **/
+unsigned int CPG_ReadReg(unsigned int offset);
+void CPG_WriteReg(unsigned int offset, unsigned int value);
+
+int CPG_MoveToActivePLL(e_cpg_pll_num_t pll_num, st_cpg_pll_param_t *p_set_data);
+int CPG_GetStatusPLL(e_cpg_pll_num_t pll_num, unsigned int *p_data);
+
+void CPG_SetDifClkFreq(e_cpg_divsel_t target_reg, unsigned short int target, unsigned short int set_value);
+int CPG_SetClockCtrl(unsigned char reg_num, unsigned short int target, unsigned short int set_value);
+int CPG_SetResetCtrl(unsigned char reg_num, unsigned short int target, unsigned short int set_value);
+int CPG_SetPDResetCtrl(unsigned short int target, unsigned short int set_value);
+int CPG_WaitResetMon(unsigned int timeout_c, unsigned int msk, unsigned int val);
+int CPG_WakeUpPLL(e_cpg_pll_num_t pll_num);
+
+#endif /* EVK_CMN_CPG_H */
diff --git b/board/renesas/rzv2ma-dev/evk_common.c b/board/renesas/rzv2ma-dev/evk_common.c
new file mode 100755
index 0000000..686a882
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_common.c
@@ -0,0 +1,77 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_common.c
+ ******************************************************************************/
+
+#include <stdint.h>
+#include "evk_common.h"
+
+#define SYSCNT_FREQUENCY    (24000000)
+#define SYSCNT_BASE_ADDRESS (0xA3F00000)
+
+#define SYSCNT_CNTCV        (0x1000)
+
+/*******************************************************************************
+ * Function Name: CMN_GetSysCnt
+ * Description  : get system counter
+ * Arguments    : none
+ * Return Value : system counter
+ ******************************************************************************/
+unsigned long int CMN_GetSysCnt(void)
+{
+	unsigned int g_syscnt_base = SYSCNT_BASE_ADDRESS;
+    return CMN_REG_Read64(g_syscnt_base + SYSCNT_CNTCV);
+}
+
+/*******************************************************************************
+ * Function Name: CMN_GetFreq4SysCnt
+ * Description  : get system counter
+ * Arguments    : none
+ * Return Value : system counter
+ ******************************************************************************/
+unsigned int CMN_GetFreq4SysCnt(void)
+{
+	unsigned int g_syscnt_base = SYSCNT_BASE_ADDRESS;
+    return SYSCNT_FREQUENCY;
+}
+
+/*******************************************************************************
+ * Function Name: CMN_DelayInUSec
+ * Description  : delayed time in microsecond
+ * Arguments    :
+ *                us -
+ *                    delay times in microsecond
+ * Return Value : none
+ ******************************************************************************/
+void CMN_DelayInUSec(unsigned long int us)
+{
+    unsigned long int start = CMN_GetSysCnt();
+    unsigned long int cycles = (CMN_GetFreq4SysCnt() / 1000000UL) * us;
+
+    while ((CMN_GetSysCnt() - start) < cycles)
+    {
+        asm volatile("nop");
+    }
+}
+
diff --git b/board/renesas/rzv2ma-dev/evk_common.h b/board/renesas/rzv2ma-dev/evk_common.h
new file mode 100755
index 0000000..9d4ba73
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_common.h
@@ -0,0 +1,133 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_common.h
+ ******************************************************************************/
+
+#ifndef EVK_COMMON_H
+#define EVK_COMMON_H
+
+/*
+ * Macro definitions
+ */
+#ifndef NULL
+#define NULL    ((void*)0)
+#endif  /* !defined(NULL) */
+
+/*
+ * Global Typedef definitions
+ */
+typedef enum
+{
+    CMN_SUCCESS = 0,
+    CMN_ERROR   = -1
+} e_evk_cmn_error_no_t;
+
+/******************************************************************************
+ Prototype define
+ *****************************************************************************/
+void CMN_DelayInUSec(unsigned long int us);
+unsigned long int CMN_GetSysCnt(void);
+unsigned int CMN_GetFreq4SysCnt(void);
+
+/*******************************************************************************
+ * Function Name: CMN_REG_Read32
+ * Description  : read access to Register in unsigned int.
+ *
+ * Arguments    : addr -
+ *                    address for read access
+ * Return Value : value -
+ *                    read data.
+ ******************************************************************************/
+static inline unsigned int CMN_REG_Read32(unsigned int addr)
+{
+    /** pointer is (unsigned int *) */
+    return *((volatile unsigned int *)addr);
+}
+
+/*******************************************************************************
+ * Function Name: CMN_REG_Write32
+ * Description  : write access to Register in unsigned int.
+ *
+ * Arguments    : addr -
+ *                    address for write access
+ *                value -
+ *                    write data
+ * Return Value : non -
+ *
+ ******************************************************************************/
+static inline void CMN_REG_Write32(unsigned int addr, unsigned int value)
+{
+    /** sizeof(unsigned int) == sizeof(unsigned int *) */
+    *((volatile unsigned int *)addr) = value;
+}
+
+/*******************************************************************************
+ * Function Name: CMN_REG_Read64
+ * Description  : read access to Register in unsigned long int.
+ *
+ * Arguments    : addr -
+ *                    address for read access
+ * Return Value : value -
+ *                    read data.
+ ******************************************************************************/
+static inline unsigned long int CMN_REG_Read64(unsigned int addr)
+{
+    /** sizeof(unsigned int) == sizeof(unsigned long int *) */
+    return *((volatile unsigned long int *)addr);
+}
+
+/*******************************************************************************
+ * Function Name: CMN_REG_Write64
+ * Description  : write access to Register in unsigned long int.
+ *
+ * Arguments    : addr -
+ *                    address for write access
+ *                value -
+ *                    write data
+ * Return Value : non -
+ *
+ ******************************************************************************/
+static inline void CMN_REG_Write64(unsigned int addr, unsigned long int value)
+{
+    /** sizeof(unsigned int) == sizeof(unsigned long int *) */
+    *((volatile unsigned long int *)addr) = value;
+}
+
+/*******************************************************************************
+ * Function Name: CMN_DelayInUS
+ * Description  : Does an example task. Making this longer just to see how it
+ *                wraps.
+ * Arguments    : index -
+ *                    Where to start looking
+ *                p_output -
+ *                    Pointer of where to put the output data
+ * Return Value : count -
+ *                    How many entries were found
+ ******************************************************************************/
+static inline void CMN_DelayInUS(unsigned long int us)
+{
+    CMN_DelayInUSec(us);
+}
+
+#endif /* !defined EVK_COMMON_H */
diff --git b/board/renesas/rzv2ma-dev/evk_psc.c b/board/renesas/rzv2ma-dev/evk_psc.c
new file mode 100755
index 0000000..b597773
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_psc.c
@@ -0,0 +1,46 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+#include <stdint.h>
+#include "evk_psc.h"
+
+static void psc_set_rst(unsigned char rst);
+static void psc_set_cken(unsigned char cken);
+
+void evk_psc_init(void)
+{
+    psc_set_rst(1);//psc module reset de-assert
+    psc_set_cken(1);//psc module clock enable
+	return;
+}
+
+static void psc_set_rst(unsigned char rst)
+{
+    PSC_WRITE_REG(PSC_RST, (rst & 0x1));
+	return;
+}
+
+static void psc_set_cken(unsigned char cken)
+{
+    PSC_WRITE_REG(PSC_CKEN, (cken & 0x1));
+	return;
+}
diff --git b/board/renesas/rzv2ma-dev/evk_psc.h b/board/renesas/rzv2ma-dev/evk_psc.h
new file mode 100755
index 0000000..d9135b7
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_psc.h
@@ -0,0 +1,35 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+#ifndef EVK_PSC_H_
+#define EVK_PSC_H_
+
+
+#define PSC_BASE_ADDR     (0x00000000A3700000ULL)
+#define PSC_RST           (PSC_BASE_ADDR + 0x0000)
+#define PSC_CKEN          (PSC_BASE_ADDR + 0x0004)
+
+#define PSC_WRITE_REG(addr, data)  (*((volatile unsigned int   *)((unsigned int)(addr))) = ((unsigned int  )(data)))
+
+void evk_psc_init(void);
+
+#endif  /* !defined(EVK_PSC_H_) */
diff --git b/board/renesas/rzv2ma-dev/evk_sys.c b/board/renesas/rzv2ma-dev/evk_sys.c
new file mode 100755
index 0000000..39b1f7d
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_sys.c
@@ -0,0 +1,116 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_sys.c
+ * Description  : operation functions for SYS
+ ******************************************************************************/
+
+#include <stdint.h>
+
+#include "evk_common.h"
+#include "evk_sys.h"
+
+/*******************************************************************************
+ * Function Name: sys_GetRegOffset
+ * Description  : get register offset
+ *
+ * Arguments    : value -
+ *                    target value
+ * Return Value : offset -
+ *                    register offset value
+ ******************************************************************************/
+static inline unsigned int sys_GetRegOffset(unsigned int value)
+{
+    return (((((value) & 0xFF00) >> 8) - 1) * 4);
+}
+/*******************************************************************************
+ End of function sys_GetRegOffset
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * Function Name: SYS_ReadReg
+ * Description  : Read access to a SYSTEM Register in unsigned int.
+ *
+ * Arguments    : offset -
+ *                    SYSTEM Register Offset.
+ * Return Value : read data -
+ *
+ ******************************************************************************/
+unsigned int SYS_ReadReg(unsigned int offset)
+{
+    return (CMN_REG_Read32(SYS_BASE_ADDRESS + offset));
+}
+/*******************************************************************************
+ End of function SYS_ReadReg
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Function Name: SYS_WriteReg
+ * Description  : Write access to a SYSTEM Register in unsigned int.
+ *
+ * Arguments    : offset -
+ *                    SYSTEM Register Offset.
+ *                value -
+ *                    Write data.
+ * Return Value : none -
+ *
+ ******************************************************************************/
+void SYS_WriteReg(unsigned int offset, unsigned int value)
+{
+    CMN_REG_Write32((SYS_BASE_ADDRESS + offset), value);
+}
+/*******************************************************************************
+ End of function SYS_WriteReg
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * Function Name: SYS_MoveToActiveSRAM
+ * Description  : target SRAM change state to active.
+ *
+ * Arguments    : target -
+ *                    target SRAM kind
+ * Return Value : none -
+ *
+ ******************************************************************************/
+void SYS_MoveToActiveSRAM(e_sys_target_sram_t target)
+{
+    unsigned int reg_addr_sram_sdm = SYS_SRAM_SDM1;
+    unsigned int reg_addr_sram_rs  = SYS_SRAM_RS1;
+    unsigned int target_bit;
+
+    reg_addr_sram_sdm += sys_GetRegOffset(target);
+    reg_addr_sram_rs  += sys_GetRegOffset(target);
+    target_bit = 0x01 << (target & 0xFF);
+    target_bit = (target_bit << 16);
+
+    SYS_WriteReg( reg_addr_sram_rs, target_bit);
+    CMN_DelayInUS(1);
+    SYS_WriteReg( reg_addr_sram_sdm, target_bit);
+    CMN_DelayInUS(1);
+}
+/*******************************************************************************
+ End of function SYS_MoveToActiveSRAM
+ ******************************************************************************/
+
diff --git b/board/renesas/rzv2ma-dev/evk_sys.h b/board/renesas/rzv2ma-dev/evk_sys.h
new file mode 100755
index 0000000..1f25c46
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_sys.h
@@ -0,0 +1,127 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_sys.h
+ * Description  : register and API information for SYS
+ ******************************************************************************/
+
+#ifndef EVK_SYS_H_
+#define EVK_SYS_H_
+
+#define SYS_BASE_ADDRESS            (0xA3F03000)
+
+
+#define SYS_PERI0_BANK              (0x0030)
+#define SYS_PERI1_BANK              (0x0034)
+#define SYS_DRP_BANK                (0x0038)
+
+
+#define SYS_MD_MON                  (0x0100)
+#define SYS_VERSION                 (0x0104)
+#define SYS_RAMA_ECC_CNT            (0x0110)
+#define SYS_RAMA_INIT               (0x0114)
+#define SYS_RAMA_INIT_END           (0x0118)
+
+
+#define SYS_SRAM_SDM1               (0x0180)
+#define SYS_SRAM_SDM2               (0x0184)
+#define SYS_SRAM_SDM3               (0x0188)
+
+
+#define SYS_SRAM_RS1                (0x0190)
+#define SYS_SRAM_RS2                (0x0194)
+#define SYS_SRAM_RS3                (0x0198)
+
+
+#define BA00                            BIT(0)
+#define BA01                            BIT(1)
+#define BA02                            BIT(2)
+#define BA03                            BIT(3)
+#define BA04                            BIT(4)
+#define BA05                            BIT(5)
+#define BA06                            BIT(6)
+#define BA07                            BIT(7)
+#define BA08                            BIT(8)
+#define BA09                            BIT(9)
+#define BA10                            BIT(10)
+#define BA11                            BIT(11)
+#define BA12                            BIT(12)
+#define BA13                            BIT(13)
+#define BA14                            BIT(14)
+#define BA15                            BIT(15)
+#define BA_WE00                         BIT(16)
+#define BA_WE01                         BIT(17)
+#define BA_WE02                         BIT(18)
+#define BA_WE03                         BIT(19)
+#define BA_WE04                         BIT(20)
+#define BA_WE05                         BIT(21)
+#define BA_WE06                         BIT(22)
+#define BA_WE07                         BIT(23)
+#define BA_WE08                         BIT(24)
+#define BA_WE09                         BIT(25)
+#define BA_WE10                         BIT(26)
+#define BA_WE11                         BIT(27)
+#define BA_WE12                         BIT(28)
+#define BA_WE13                         BIT(29)
+#define BA_WE14                         BIT(30)
+#define BA_WE15                         BIT(31)
+
+
+typedef enum
+{
+    SYS_SRAM_CST        = 0x100,
+    SYS_SRAM_SDI0,
+    SYS_SRAM_SDI1,
+    SYS_SRAM_EMMC,
+    SYS_SRAM_DMY1,
+    SYS_SRAM_DMY2,
+    SYS_SRAM_USB_HOST,
+    SYS_SRAM_USB_FUNC,
+    SYS_SRAM_ETH0,
+    SYS_SRAM_DMY3        = 0x10A,
+    SYS_SRAM_DMY4       = 0x10C,
+    SYS_SRAM_DMY5,
+    SYS_SRAM_DMY6       = 0x200,
+    SYS_SRAM_DMY7,
+    SYS_SRAM_DMY8,
+    SYS_SRAM_SRAMA      = 0x204,
+    SYS_SRAM_SRAMB0     = 0x208,
+    SYS_SRAM_SRAMB1,
+    SYS_SRAM_SRAMB2,
+    SYS_SRAM_SRAMB3,
+    SYS_SRAM_RESERVE0       = 0x300,
+    SYS_SRAM_RESERVE1,
+    SYS_SRAM_RESERVE2,
+    SYS_SRAM_RESERVE3,
+    SYS_SRAM_RESERVE4,
+    SYS_SRAM_RESERVE5,
+    SYS_SRAM_RESERVE9       = 0x309,
+    SYS_SRAM_RESERVE13      = 0x30D,
+} e_sys_target_sram_t;
+
+unsigned int SYS_ReadReg(unsigned int offset);
+void SYS_WriteReg(unsigned int offset, unsigned int value);
+
+void SYS_MoveToActiveSRAM(e_sys_target_sram_t target);
+
+#endif  /* !defined(EVK_SYS_H_) */
diff --git b/board/renesas/rzv2ma-dev/evk_usbtest.h b/board/renesas/rzv2ma-dev/evk_usbtest.h
new file mode 100755
index 0000000..d8851f2
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/evk_usbtest.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+/*******************************************************************************
+ * File Name    : evk_usbtest.h
+ ******************************************************************************/
+
+#ifndef EVK_USBTEST_H_
+#define EVK_USBTEST_H_
+
+#define USBTEST_BASE_ADDRESS     (0xA3F90000)
+
+#define USBTEST_RESET1		(0x0000)+USBTEST_BASE_ADDRESS
+#define USBTEST_RESET2		(0x0004)+USBTEST_BASE_ADDRESS
+#define USBTEST_PIPE_MON1		(0x0124)+USBTEST_BASE_ADDRESS
+#define USBTEST_CLKRST2		(0x0304)+USBTEST_BASE_ADDRESS
+#define USBTEST_CLKRST3		(0x0308)+USBTEST_BASE_ADDRESS
+
+#endif  /* !defined(EVK_USBTEST_H_) */
diff --git b/board/renesas/rzv2ma-dev/rzv2ma-dev.c b/board/renesas/rzv2ma-dev/rzv2ma-dev.c
new file mode 100755
index 0000000..ae73982
--- /dev/null
+++ b/board/renesas/rzv2ma-dev/rzv2ma-dev.c
@@ -0,0 +1,532 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+#include <common.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <linux/errno.h>
+#include <asm/system.h>
+#include "evk_common.h"
+#include "evk_cmn_cpg.h"
+#include "evk_usbtest.h"
+#include "evk_sys.h"
+#include "evk_psc.h"
+#include <init.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void drp_a_init(void){
+
+	uint32_t regval;
+	
+	//Initialize the PLL6
+	regval = CMN_REG_Read32(0xa350003c);
+	while((regval & 0x11) != 0x00){
+		regval = CMN_REG_Read32(0xa350003c);
+		CMN_DelayInUS(1);
+	}
+	CMN_REG_Write32(0xa3500034, 0x00001a42);
+	CMN_REG_Write32(0xA3500038, 0x00150A01);
+
+	//Release standby mode with PLL6
+	CMN_REG_Write32(0xA3500030, 0x00010001);
+	regval = CMN_REG_Read32(0xa350003c);
+	while((regval & 0x11) != 0x11){
+		regval = CMN_REG_Read32(0xa350003c);
+		CMN_DelayInUS(1);
+	}
+	
+	//Power on with PD_DRPA
+	CMN_REG_Write32(0xA3600018, 0x0BB70BB7);
+	CMN_REG_Write32(0xa3600000, 0x00000015);
+	regval = CMN_REG_Read32(0xa3600044);
+	while((regval & 0x1) != 0x1){
+		regval = CMN_REG_Read32(0xa3600044);
+		CMN_DelayInUS(1000);
+	}
+	
+	//Clear interrupt status with PMC
+	CMN_REG_Write32(0xa3600048, 0x00000001);
+	
+	//Clock supply with PD_DRP
+	CMN_REG_Write32(0xa350044c,0x00040004);
+	CMN_DelayInUS(1000);
+	
+	//Isolation off with DRP
+	CMN_REG_Write32(0xa360002c, 0x00000000);
+	regval = CMN_REG_Read32(0xa360002c);
+	while((regval & 0x8000) != 0x8000){
+		regval = CMN_REG_Read32(0xa360002c);
+		CMN_DelayInUS(1000);
+	}
+	//Clock supply and deassert with DRP
+	CMN_REG_Write32(0xa350044c, 0x00030003);
+	CMN_DelayInUS(10000);
+	
+	CMN_REG_Write32(0xa3500620, 0x00010001);
+	CMN_DelayInUS(1);
+
+}
+
+static void drp_b_init(void){
+
+	uint32_t regval;
+
+	CMN_REG_Write32(0xa3600000, 0x00000016);
+	regval = CMN_REG_Read32(0xa3600044);
+	while((regval & 0x1) != 0x1){
+		regval = CMN_REG_Read32(0xa3600044);
+		CMN_DelayInUS(1);
+	}
+	
+	//Clear interrupt status with PMC
+	CMN_REG_Write32(0xa3600048, 0x00000001);
+
+	CMN_REG_Write32(0xa3500450,0x00040004);
+	CMN_DelayInUS(1000);
+
+	//Isolation off with DRP
+	CMN_REG_Write32(0xa3600030, 0x00000000);
+	regval = CMN_REG_Read32(0xa3600030);
+	while((regval & 0x8000) != 0x8000){
+		regval = CMN_REG_Read32(0xa360002c);
+		CMN_DelayInUS(1000);
+	}
+	
+	//Clock supply and deassert with DRP
+	CMN_REG_Write32(0xa3500450, 0x00030003);
+	CMN_DelayInUS(10000);
+
+	CMN_REG_Write32(0xa3500624, 0x00010001);
+	CMN_DelayInUS(1);
+
+}
+
+static void vcd_init(void)
+{
+	uint32_t regval;
+
+	// Power on with PD_VIDEO1
+	// control PMC reg
+	CMN_REG_Write32(0xa3600018, 0x00000BB7);   /* Set PD_ON_TIM bit     */
+	regval = CMN_REG_Read32(0xa3600004);       /* Get PD_BUSY bit       */
+	while(regval & 0x8000)
+	{
+		regval = CMN_REG_Read32(0xa3600004);   /* Get PD_BUSY bit       */
+		CMN_DelayInUS(1000);
+	}
+
+	CMN_REG_Write32(0xa3600000, 0x00000013);   /* Set SPLY_ENA bit      */
+	regval = CMN_REG_Read32(0xa3600044);       /* Get PD_NUM bit        */
+
+	while ((regval & 0x1) != 0x1) 
+	{
+		regval = CMN_REG_Read32(0xa3600044);
+		CMN_DelayInUS(1000);
+	}
+
+	CMN_REG_Write32(0xa3600048, 0x00000001);   /* Set PMC_INT_CLR bit   */
+
+	/* Power domain control : CPG_PD_RST reg : release PD_VD1A/B, PD_VD0 reset */
+	CPG_SetPDResetCtrl(0x000E, 0x000E);
+
+	/* disable supply clock : use 400MHz no settiing */
+	CPG_SetClockCtrl(26, 0x0F20, 0x0F20);      /* Set VCD_A/PCLK, JPG0/1_ACLK  */
+
+	CMN_REG_Write32(0xa3600024, 0x00000000);   /* Clear PD_ISO_EN bit(D0 bit)  */
+	regval = CMN_REG_Read32(0xa3600024);       /* Get PD_ISO_DONE bit(D15 bit) */
+
+	while((regval & 0x8000) != 0x8000)
+	{
+		regval = CMN_REG_Read32(0xa3600024);   /* Get PD_ISO_DONE bit(D15 bit) */
+		CMN_DelayInUS(3);
+	}
+
+	/* Control CPG_RST14 reg (offset 634h) : PD_VIDEO1 Reset / deassert all UNITs */
+	CPG_SetResetCtrl(14, 0x03FD, 0x03FD);
+	CMN_DelayInUS(3);
+
+	/* Control CPG_CLK_ON25/26 reg (offset 460h/464h): PD_VIDEO1 clock on all UNITs */
+	CPG_SetClockCtrl(25, 0x003B, 0x003B);
+	CPG_SetClockCtrl(26, 0x001E, 0x001E);
+	CMN_DelayInUS(3);
+
+	/* Control CPG_RST7 reg (offset 618h) : set ICB_PD_VD1_RST_N */
+	CPG_SetResetCtrl(7, 0x0008, 0x0008);
+	CMN_DelayInUS(3);
+
+	/* Control CPG_CLK_ON16/18 reg (offset 43Ch/444h): clock on ICB */
+	CPG_SetClockCtrl(16, 0x0080, 0x0080);
+	CPG_SetClockCtrl(18, 0x3F00, 0x3F00);
+	CMN_DelayInUS(3);
+
+	CMN_REG_Write32(0xa3600038, 0x00080000);   /* Clear PD_VIDEO1_IDLE_REQ bit(D0 bit)  */
+	regval = CMN_REG_Read32(0xa360003C);       /* Get PD_VIDEO1_ACT_DONE bit(D11 bit) */
+
+	while((regval & 0x0800) != 0x0800)
+	{
+		regval = CMN_REG_Read32(0xa360003C);   /* Get PD_VIDEO1_ACT_DONE bit(D11 bit) */
+		CMN_DelayInUS(100);
+	}
+}
+
+static void pcie_init (void)
+{
+	// set SYS register
+	CMN_REG_Write32(0xA3F03094,0x00000000);
+	CMN_REG_Write32(0xA3F03090,0x00000001);
+	CMN_DelayInUS(10);
+
+	/* assert RESET */
+	CPG_SetResetCtrl(3, 0x1000, 0x0000);
+	CMN_DelayInUS(2);
+
+	/* disable supply clock */
+	CPG_SetClockCtrl(4, 0x0007, 0x0000);
+	CMN_DelayInUS(2);
+
+	/* deassert RESET */
+	CPG_SetResetCtrl(3, 0x1000, 0x1000);
+	CMN_DelayInUS(2);
+
+	/* enable supply clock */
+	CPG_SetClockCtrl(4, 0x0007, 0x0007);
+	CMN_DelayInUS(2);
+}
+
+static void div_init(void)
+{
+	int t;
+
+	/* select  DEVB(400MHz) ,select DEVD(200MHz) and select DEVE(100MHz) */
+	CPG_WriteReg(CPG_SYS_DDIV, (CPG_SYS_DDIV_WEN_DIVB|CPG_SYS_DDIV_WEN_DIVE|CPG_SYS_DDIV_WEN_DIVD));
+	t = 0;
+	while (1000000 > t++)
+	{
+		if (0 == (CPG_ReadReg(CPG_CLKSTATUS) & CPG_CLKSTATUS_DIVX))
+		{
+			break;
+		}
+		CMN_DelayInUS(10);
+	}
+
+}
+
+static void sdi_emm_init(void)
+{
+	/* select SDI0 SDI1 EMM clock source(200MHz) */
+	CPG_WriteReg(CPG_SDIEMM_SSEL, (CPG_SDIEMM_SSEL_SELSDI|CPG_SDIEMM_SSEL_WEN_SELSDI));
+
+	/* enable supply clock */
+	CPG_SetClockCtrl(3, 0x0fff, 0x0fff);
+	CMN_DelayInUS(1);
+
+	/* asset RESET */
+	CPG_SetResetCtrl(3, 0x0007, 0x0000);
+	CPG_WaitResetMon(0, CPG_RST_MON_SDI0, CPG_RST_MON_SDI0);
+	CPG_WaitResetMon(0, CPG_RST_MON_SDI1, CPG_RST_MON_SDI1);
+	CPG_WaitResetMon(0, CPG_RST_MON_EMM,  CPG_RST_MON_EMM);
+
+	/* deasset RESET */
+	CPG_SetResetCtrl(3, 0x0007, 0x0007);
+	CPG_WaitResetMon(0, CPG_RST_MON_SDI0, 0);
+	CPG_WaitResetMon(0, CPG_RST_MON_SDI1, 0);
+	CPG_WaitResetMon(0, CPG_RST_MON_EMM,  0);
+}
+
+static void usb_init(void)
+{
+	/* usb reset assart */
+	CPG_SetResetCtrl(3, 0x0780, 0x0000);
+	CMN_DelayInUS(1);//50ns
+
+	/* usb clock off */
+	CPG_SetClockCtrl(4, 0x0070, 0x0000);
+	CMN_DelayInUS(1);//125ns
+
+	/* usb reset assart */
+	CPG_SetResetCtrl(3, 0x0780, 0x0780);
+	CMN_DelayInUS(1);//50ns
+
+	/* usb clock on */
+	CPG_SetClockCtrl(4, 0x0070, 0x0070);
+	CMN_DelayInUS(1);//125ns
+
+	//USB TEST Module initialize
+	CMN_REG_Write32(USBTEST_RESET2,  0x00000001);
+	CMN_DelayInUS(10);
+	CMN_REG_Write32(USBTEST_CLKRST2, 0x00000005);
+	CMN_REG_Write32(USBTEST_CLKRST2, 0x00000004);
+	CMN_DelayInUS(20);
+	CMN_REG_Write32(USBTEST_RESET1,  0x00000300);
+	CMN_REG_Write32(USBTEST_RESET1,  0x00000000);
+	CMN_DelayInUS(75);
+}
+
+static void iic_init(void)
+{
+	/* asset RESET */
+	CPG_SetResetCtrl(6, 0x0300, 0x0000);
+	CMN_DelayInUS(1);
+
+	/* disable supply clock */
+	CPG_SetClockCtrl(9, 0x1000, 0x0000);
+	CPG_SetClockCtrl(10, 0x1000, 0x0000);
+	CMN_DelayInUS(1);
+
+	/* deasset RESET */
+	CPG_SetResetCtrl(6, 0x0300, 0x0300);
+	CMN_DelayInUS(1);
+
+	/* enable supply clock */
+	CPG_SetClockCtrl(9, 0x1000, 0x1000);
+	CPG_SetClockCtrl(10, 0x1000, 0x1000);
+	CMN_DelayInUS(1);
+}
+
+static void ether_init(void)
+{
+	/* eth0 clock on */
+	CPG_SetClockCtrl(4, 0x0300, 0x0300);
+	CPG_SetClockCtrl(16, 0x2000, 0x2000);
+	CMN_DelayInUS(1);
+
+	/* eth0 reset assart */
+	CPG_SetResetCtrl(3, 0x0800, 0x0000);
+	CPG_WaitResetMon(0, CPG_RST_MON_ETH0, CPG_RST_MON_ETH0);
+
+	/* eth0 reset deassert */
+	CPG_SetResetCtrl(3, 0x0800, 0x0800);
+	CPG_WaitResetMon(0, CPG_RST_MON_ETH0, 0);
+}
+
+static void pwm_init(void)
+{
+	CPG_SetClockCtrl(13, 0x0FF1, 0x0FF1);
+	CPG_SetClockCtrl(14, 0x0FF1, 0x0FF1);
+	CMN_DelayInUS(1);
+	
+	/* PWM0-7 reset assart */
+	CPG_SetResetCtrl(6, 0x0030, 0x0000);
+	CPG_WaitResetMon(0, CPG_RST_MON_PWM_0 | CPG_RST_MON_PWM_1, CPG_RST_MON_PWM_0 | CPG_RST_MON_PWM_1);
+	
+	/* PWM0-7 reset deassert */
+	CPG_SetResetCtrl(6, 0x0030, 0x0030);
+	CPG_WaitResetMon(0, CPG_RST_MON_PWM_0 | CPG_RST_MON_PWM_1, 0);
+}
+
+static void csi_init(void)
+{
+	CPG_SetClockCtrl(15, 0x3F03, 0x3F03);
+	CMN_DelayInUS(1);
+	
+	/* CSI0-5 reset assart */
+	CPG_SetResetCtrl(6, 0x00C0, 0x0000);
+	CPG_WaitResetMon(0, CPG_RST_MON_CSI_1|CPG_RST_MON_CSI_2, CPG_RST_MON_CSI_1|CPG_RST_MON_CSI_2);
+	
+	/* CSI0-5 reset deassert */
+	CPG_SetResetCtrl(6, 0x00C0, 0x00C0);
+	CPG_WaitResetMon(0, CPG_RST_MON_CSI_1|CPG_RST_MON_CSI_2, 0);
+
+	CPG_SetClockCtrl(4, 0x0007, 0x0007);
+	CMN_DelayInUS(1);
+	CPG_SetResetCtrl(3, 0x1000, 0x0000);
+	CMN_DelayInUS(1);
+	CPG_SetResetCtrl(3, 0x1000, 0x1000);
+	CMN_DelayInUS(1);
+}
+
+static void tim_init(void)
+{
+	/* TIM group A-D reset assart */
+	CPG_SetResetCtrl(6, 0x000F, 0x0000);
+	CMN_DelayInUS(1);
+	
+	/* TIM group A and TIM 0-7 clock off */
+	CPG_SetClockCtrl(9, 0x0FF1, 0x0000);
+	/* TIM group B and TIM 8-15 clock off */
+	CPG_SetClockCtrl(10, 0x0FF1, 0x0000);
+	/* TIM group C and TIM 16-23 clock off */
+	CPG_SetClockCtrl(11, 0x0FF1, 0x0000);
+	/* TIM group D and TIM 24-31 clock off */
+	CPG_SetClockCtrl(12, 0x0FF1, 0x0000);
+	CMN_DelayInUS(1);
+
+	/* TIM group A-D reset deassert */
+	CPG_SetResetCtrl(6, 0x000F, 0x000F);
+	CMN_DelayInUS(1);
+
+	/* TIM group A and TIM 0-7 clock on */
+	CPG_SetClockCtrl(9, 0x0FF1, 0x0FF1);
+	/* TIM group B and TIM 8-15 clock on */
+	CPG_SetClockCtrl(10, 0x0FF1, 0x0FF1);
+	/* TIM group C and TIM 16-23 clock on */
+	CPG_SetClockCtrl(11, 0x0FF1, 0x0FF1);
+	/* TIM group D and TIM 24-31 clock on */
+	CPG_SetClockCtrl(12,0x0FF1, 0x0FF1);
+	CMN_DelayInUS(1);
+}
+	
+static void dmaa_init(void)
+{
+	/* DMAA clock on */ 
+	CPG_SetClockCtrl(1, 0x0800, 0x0800);
+		
+	/* DMAA reset assart */
+	CPG_SetResetCtrl(1, 0x0080, 0x0000);
+	CPG_WaitResetMon(0, CPG_RST_MON_DMAA,CPG_RST_MON_DMAA);
+	
+	/* DMAA reset deassert */
+	CPG_SetResetCtrl(1, 0x0080, 0x0080);
+	CPG_WaitResetMon(0, CPG_RST_MON_DMAA,0);
+}
+
+	
+static void evk_cpg_init(void)
+{
+	int t;
+	do
+	{	
+		/**********************************/
+		/*    Clock division control      */
+		/**********************************/
+		div_init();
+		
+		/**********************************/
+		/*    SDI0 SDI1 EMM               */
+		/**********************************/
+		sdi_emm_init();
+		
+		/**********************************/
+		/*    USB                         */
+		/**********************************/
+		usb_init();
+		
+		/**********************************/
+		/*    IIC0-3                      */
+		/**********************************/
+		iic_init();
+		
+		/**********************************/
+		/*    ETH0                        */
+		/**********************************/
+		ether_init();
+		
+		/**********************************/
+		/*    PWM0-15                     */
+		/**********************************/
+		pwm_init();
+		
+		/**********************************/
+		/*    CSI0-5                      */
+		/**********************************/
+		csi_init();
+		
+		/**********************************/
+		/*    TIM0-31                     */
+		/**********************************/
+		tim_init();
+		
+		/**********************************/
+		/*    DMAA                        */
+		/**********************************/
+		dmaa_init();
+
+		/**********************************/
+		/*    DRPA                        */
+		/**********************************/
+		drp_a_init();
+		drp_b_init();
+		
+		/**********************************/
+		/*    VCD                         */
+		/**********************************/
+		vcd_init();
+		pcie_init();
+
+	}
+	while (0);
+	return;
+}
+
+int32_t ilStartUpUART(void)
+{
+	return CMN_SUCCESS;
+}
+
+extern void _start(void);
+
+void s_init(void)
+{
+
+	/* change the EL2 with ca53 core0 */
+	if(3 == current_el()){
+
+		armv8_switch_to_el2((u64)NULL, 0, 0, 0,
+							_start,
+							ES_TO_AARCH64);
+	}
+	
+	return;
+}
+
+int board_early_init_f(void)
+{
+	/* move to active for SRAM in ETH0 */
+	SYS_MoveToActiveSRAM(SYS_SRAM_ETH0);
+
+	evk_cpg_init();
+	evk_psc_init();
+	
+	/*- Release Ether PHY reset : PFC_P17_GPIO_DO -*/
+	CMN_REG_Write32(0xB6250440, 0x10001);
+	
+	return 0;
+}
+
+int board_init(void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	if (fdtdec_setup_mem_size_base() != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	fdtdec_setup_memory_banksize();
+
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+}
+
diff --git b/configs/r9a09g055ma3gbg_rzv2ma_defconfig b/configs/r9a09g055ma3gbg_rzv2ma_defconfig
new file mode 100755
index 0000000..5ae509b
--- /dev/null
+++ b/configs/r9a09g055ma3gbg_rzv2ma_defconfig
@@ -0,0 +1,77 @@
+CONFIG_ARM=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x08000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_RCAR_64=y
+#CONFIG_RCAR_GEN3=y
+CONFIG_R9A09G055MA3GBG=y
+CONFIG_TARGET_RZV2MA=y
+CONFIG_ARCH_MISC_INIT=n
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_FIT=y
+# CONFIG_ARCH_FIXUP_FDT_MEMORY is not set
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="root=/dev/nfs rw nfsroot=192.168.1.10:/nfs/rzv2m,nfsvers=3 ip=192.168.1.11:192.168.1.10::255.255.255.0:rzv2m:eth0"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="r9a09g055ma3gbg-evaluation-board.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="r9a09g055ma3gbg-rzv2ma-u-boot"
+CONFIG_ENV_IS_IN_MMC=y
+#CONFIG_ENV_IS_IN_FAT=y
+#CONFIG_ENV_FAT_INTERFACE="mmc"
+#CONFIG_ENV_FAT_DEVICE_AND_PART="0:1"
+#CONFIG_ENV_FAT_FILE="rzv2ma-u-boot.env"
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_BLK=y
+CONFIG_CLK=y
+#CONFIG_CLK_RENESAS=y
+CONFIG_DM_GPIO=y
+#CONFIG_RCAR_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_RENESAS_SDHI=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PINCTRL=y
+CONFIG_PINCONF=y
+CONFIG_PINCTRL_PFC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+#CONFIG_SCIF_CONSOLE=y
+CONFIG_DM_SERIAL=n
+CONFIG_RZV2M_SERIAL=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_PRAM=1
+CONFIG_ENV_OFFSET=0xFFFE0000
+CONFIG_SYS_CONFIG_NAME="rzv2ma"
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 737a7c0..127eeab 100755
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -941,6 +941,6 @@ config SYS_SDMR
 
 config RZV2M_SERIAL
        bool "Renesas RZ/V2M UART support"
-       depends on TARGET_RZV2M
+       depends on TARGET_RZV2M || TARGET_RZV2MA
 
 endmenu
diff --git a/dts/Makefile b/dts/Makefile
index c1da32c..8de3173 100755
--- a/dts/Makefile
+++ b/dts/Makefile
@@ -33,7 +33,9 @@ endif
 
 dtb-$(CONFIG_ARCH_RMOBILE) += \
        r9a09g011gbg-rzv2m-u-boot.dtb \
-       r9a09g011gbg-rzv2m.dtb
+       r9a09g011gbg-rzv2m.dtb \
+       r9a09g055ma3gbg-rzv2ma-u-boot.dtb \
+       r9a09g055ma3gbg-rzv2ma.dtb \
 targets += dt.dtb
 
 $(DTB): arch-dtbs
diff --git b/include/configs/rzv2ma.h b/include/configs/rzv2ma.h
new file mode 100755
index 0000000..b9f2338
--- /dev/null
+++ b/include/configs/rzv2ma.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * include/configs/rzv2ma.h
+ *     This file is rzv2ma board configuration.
+ *
+ * Copyright (C) 2022 Renesas Electronics Corporation
+ */
+
+#ifndef __RZV2MA_H
+#define __RZV2MA_H
+
+#include <asm/arch/rmobile.h>
+
+/* Enter the kernel on EL1 */
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII
+#define CONFIG_BITBANGMII_MULTI
+
+/* Generic Timer Definitions (use in assembler source) */
+#define COUNTER_FREQUENCY	24000000	/* 24MHz from CNT_CLK */
+
+/* Environment in eMMC, at the end of 2nd "boot sector" */
+#undef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_OFFSET		(-CONFIG_ENV_SIZE)
+#undef CONFIG_SYS_MMC_ENV_DEV
+#define CONFIG_SYS_MMC_ENV_DEV		1
+#undef CONFIG_SYS_MMC_ENV_PART
+#define CONFIG_SYS_MMC_ENV_PART		2
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_ARCH_CPU_INIT
+#undef CONFIG_DISPLAY_CPUINFO
+#define CONFIG_SYS_INIT_SP_ADDR 0x000BFFFC
+
+/* Generic Interrupt Controller Definitions */
+#define CONFIG_GICV2
+#define GICD_BASE	0x82010000
+#define GICC_BASE	0x82020000
+
+/* MEMORY */
+#define CONFIG_SYS_SDRAM_BASE		0x00000000
+#define CONFIG_SYS_SDRAM_SIZE		0x80000000
+#define CONFIG_SYS_LOAD_ADDR		0x40007fc0
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(1 * 1024 * 1024)
+
+
+/* ENV setting */
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SECT_SIZE	(128 * 1024)
+#define CONFIG_ENV_SIZE		(CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_OVERWRITE
+//#define CONFIG_ENV_SIZE_REDUND	(CONFIG_ENV_SIZE)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"ethaddr=02:11:22:33:44:55\0" \
+	"ipaddr=192.168.1.11\0" \
+	"serverip=192.168.1.10\0" \
+	"gatewayip=192.168.0.1\0" \
+	"netmask=255.255.255.0\0" \
+	"loadaddr=0x000080000\0" \
+	"fdt_addr=0x000000000\0" \
+	"fdt_high=0x028000000\0" \
+	"fdt_file=r9a09g055ma3gbg-evaluation-board.dtb\0" \
+	"kernel=Image\0" \
+	"core1addr=0x0\0" \
+	"core1_vector=0x0\0" \
+	"bootargs_sd=setenv bootargs root=/dev/mmcblk0p2 rootwait rootfstype=ext4 rw\0" \
+	"bootsd=run bootargs_sd;" \
+	"fatload mmc 0:1 ${loadaddr} ${kernel};fatload mmc 0:1 ${fdt_addr} ${fdt_file};booti ${loadaddr} - ${fdt_addr}\0" \
+    "bootargs_nfs=setenv bootargs root=/dev/nfs rw nfsroot=${serverip}:/nfs/rzv2m,nfsvers=3 ip=${ipaddr}:${serverip}::${netmask}:rzv2m:eth0\0" \
+	"bootnfs=run bootargs_nfs;" \
+	"tftp ${loadaddr} ${kernel};tftp ${fdt_addr} ${fdt_file};booti ${loadaddr} - ${fdt_addr}\0" \
+	"bootcmd=run bootsd\0" \
+
+#endif /* __RZV2M_H */
diff --git b/include/dt-bindings/power/r9a09g055ma3gbg-sysc.h b/include/dt-bindings/power/r9a09g055ma3gbg-sysc.h
new file mode 100755
index 0000000..ac2b2ef
--- /dev/null
+++ b/include/dt-bindings/power/r9a09g055ma3gbg-sysc.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+#ifndef __DT_BINDINGS_POWER_R9A09G055MA3GBG_SYSC_H__
+#define __DT_BINDINGS_POWER_R9A09G055MA3GBG_SYSC_H__
+
+/*
+ * These power domain indices match the numbers of the interrupt bits
+ * representing the power areas in the various Interrupt Registers
+ * (e.g. SYSCISR, Interrupt Status Register)
+ */
+
+#define R8A774C0_PD_CA53_CPU0		 5
+#define R8A774C0_PD_CA53_SCU		21
+
+/* Always-on power area */
+#define R8A774C0_PD_ALWAYS_ON		32
+
+#endif /* __DT_BINDINGS_POWER_R9A09G055MA3GBG_SYSC_H__ */
diff --git b/include/dt-bindings/power/rzv2ma-sysc.h b/include/dt-bindings/power/rzv2ma-sysc.h
new file mode 100755
index 0000000..b02d5fd
--- /dev/null
+++ b/include/dt-bindings/power/rzv2ma-sysc.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only
+* intended for use with Renesas products. No other uses are authorized. This
+* software is owned by Renesas Electronics Corporation and is protected under
+* all applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+* TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+* ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+* FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+* ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+* BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software
+* and to discontinue the availability of this software. By using this software,
+* you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+*******************************************************************************/ 
+#ifndef __DT_BINDINGS_POWER_RZV2MA_SYSC_H__
+#define __DT_BINDINGS_POWER_RZV2MA_SYSC_H__
+
+/*
+ * These power domain indices match the numbers of the interrupt bits
+ * representing the power areas in the various Interrupt Registers
+ * (e.g. SYSCISR, Interrupt Status Register)
+ */
+
+#define RZV2MA_PD_CA53_SCU		1
+#define RZV2MA_PD_CA53			7
+
+/* Always-on power area */
+#define RZV2MA_PD_ALWAYS_ON		32
+
+#endif /* __DT_BINDINGS_POWER_RZV2MA_SYSC_H__ */
